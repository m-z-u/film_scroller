<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vintage Film Strip Scroller</title>

  <style>
    :root{
      /* ====== 画面（9:16） ====== */
      --stage-w: 390px;         /* 好きに変更OK */
      --stage-bg: #0a0a0a;

      /* ====== フィルム（ヴィンテージ） ====== */
      --film-base: #1f1f1e;
      --film-shade: #2a2a28;

      --sprocket-w: 38px;
      --hole-w: 18px;
      --hole-h: 12px;
      --hole-gap: 12px;
      --hole-radius: 2px;
      --hole-color: #cbbf9a;

      /* 穴列の上下パディング（JSが自動調整） */
      --sprocket-pad: 12px;

      /* ====== 写真コマ ====== */
      --window-pad-y: 10px;
      --window-pad-x: 8px;
      --frame-gap: 14px;
      --frame-h: 176px;

      /* UI（ステージ上に重ねる） */
      --ui-pad: 10px;
      --ui-gap: 10px;

      /* スクロール速度（初期値。実際はスライダーで変更） */
      --speed: 90;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif;
      background:#111;
      color:#eee;
      display:grid;
      place-items:center;
      min-height:100vh;
      padding:18px;
    }

    /* ステージ（9:16）を親コンテナとして、UIを中に重ねる */
    .stageWrap{
      width:min(var(--stage-w), 92vw);
      position:relative;
    }

    .stage{
      width:100%;
      aspect-ratio: 9 / 16;
      background:var(--stage-bg);

      /* ★外周は直角 */
      border-radius:0;
      overflow:hidden;

      position:relative;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      border:1px solid #222;
      touch-action: manipulation;
    }

    /* ====== UI（ステージの上に重ねる） ====== */
    .toolbar{
      position:absolute;
      left:var(--ui-pad);
      right:var(--ui-pad);
      top:var(--ui-pad);
      z-index:80;

      display:flex;
      gap:var(--ui-gap);
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;

      background:rgba(10,10,10,.38);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      padding:10px 12px;
      border-radius:14px;

      opacity:1;
      transform: translateY(0);
      transition: opacity .25s ease, transform .25s ease;
      user-select:none;
      pointer-events:auto;
    }
    .toolbar.hidden{
      opacity:0;
      transform: translateY(-10px);
      pointer-events:none;
    }

    .toolbar .left{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    input[type="file"]{ color:#eee; max-width: 210px; }
    .btn{
      background:#2a2a2a;
      color:#eee;
      border:1px solid rgba(255,255,255,.15);
      border-radius:10px;
      padding:8px 12px;
      cursor:pointer;
    }
    .btn:hover{ background:#333; }
    .hint{ font-size:12px; opacity:.85; }

    /* ドロップ案内 */
    .dropOverlay{
      position:absolute;
      inset:0;
      display:none;
      place-items:center;
      background:rgba(0,0,0,.55);
      border:2px dashed rgba(255,255,255,.25);
      z-index:50;
      text-align:center;
      padding:18px;
    }
    .dropOverlay.show{ display:grid; }

    /* フィルム質感 */
    .film{
      position:absolute;
      inset:0;
      background:
        radial-gradient(1200px 600px at 30% 20%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0) 35%),
        linear-gradient(90deg, rgba(0,0,0,.35), transparent 25%, transparent 75%, rgba(0,0,0,.35));
    }

    .sprocket{
      position:absolute;
      top:0; bottom:0;
      width:var(--sprocket-w);
      background:
        linear-gradient(180deg, var(--film-shade), var(--film-base)),
        repeating-linear-gradient(180deg, rgba(255,255,255,.03) 0 2px, rgba(0,0,0,0) 2px 6px);
      display:flex;
      flex-direction:column;
      align-items:center;

      /* ★上下パディングはJSが調整（下まで埋める） */
      padding-top: var(--sprocket-pad);
      padding-bottom: var(--sprocket-pad);

      gap:var(--hole-gap);
      z-index:5;
    }
    .sprocket.left{ left:0; }
    .sprocket.right{ right:0; }

    .hole{
      width:var(--hole-w);
      height:var(--hole-h);
      background:
        linear-gradient(180deg, rgba(255,255,255,.18), rgba(0,0,0,.08)),
        var(--hole-color);
      border-radius:var(--hole-radius);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.12);
      opacity:.95;
    }

    /* 画像が流れる窓 */
    .window{
      position:absolute;
      top:0; bottom:0;
      left:var(--sprocket-w);
      right:var(--sprocket-w);
      overflow:hidden;
      padding:var(--window-pad-y) var(--window-pad-x);
      z-index:10;
    }

    .strip{
      will-change: transform;
      display:flex;
      flex-direction:column;
      gap:var(--frame-gap);
      transform: translateY(0px);
    }

    /* ★白縁なし・角丸なし（直角） */
    .frame{
      background:#0f0f0f;
      height: var(--frame-h);
      overflow:hidden;
      border:0;
      border-radius:0;
      position:relative;
      box-shadow: 0 2px 0 rgba(255,255,255,.04), 0 14px 26px rgba(0,0,0,.35);
      cursor: default;
    }

    .frame img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      filter: saturate(1.02) contrast(1.03);
      transform-origin:center center;
    }

    .grain{
      pointer-events:none;
      position:absolute;
      inset:0;
      background-image:
        radial-gradient(rgba(255,245,220,.07) 1px, transparent 1px),
        radial-gradient(rgba(255,255,255,.04) 1px, transparent 1px);
      background-size: 3px 3px, 4px 4px;
      background-position: 0 0, 2px 1px;
      mix-blend-mode: overlay;
      opacity:.14;
      z-index:20;
    }
    .vignette{
      pointer-events:none;
      position:absolute;
      inset:0;
      background: radial-gradient(ellipse at center, transparent 55%, rgba(0,0,0,.35) 100%);
      z-index:21;
      opacity:.55;
    }

    .pausedBadge{
      position:absolute;
      right:10px;
      top:10px;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.20);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      z-index:85;
      display:none;
    }
    .paused .pausedBadge{ display:block; }

    /* ====== Crop Editor (paused中に写真を調整) ====== */
    .editorOverlay{
      position:absolute;
      inset:0;
      z-index:120;
      display:none;
      background:rgba(0,0,0,.65);
      backdrop-filter: blur(6px);
    }
    .editorOverlay.show{ display:block; }

    .editorPanel{
      position:absolute;
      left:12px; right:12px; top:12px;
      background:rgba(20,20,20,.72);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      padding:10px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .editorPanel .left{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .editorPanel .btn{
      background:#2a2a2a;
      color:#eee;
      border:1px solid rgba(255,255,255,.15);
      border-radius:10px;
      padding:8px 12px;
      cursor:pointer;
    }
    .editorPanel .btn:hover{ background:#333; }
    .editorPanel .hint{ font-size:12px; opacity:.85; }

    .editorStage{
      position:absolute;
      left:0; right:0;
      top:78px; bottom:0;
      display:grid;
      place-items:center;
      padding:18px;
    }

    /* 編集プレビュー枠：横長（コマの雰囲気） */
    .editorFrame{
      width:min(92vw, 520px);
      aspect-ratio: 16 / 9;
      background:#0f0f0f;
      overflow:hidden;
      border-radius:0;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
      position:relative;
    }

    .editorFrame img{
      width:100%;
      height:100%;
      object-fit:cover;
      transform-origin:center center;
      user-select:none;
      -webkit-user-drag:none;
      touch-action:none; /* ドラッグ編集用 */
    }

    .slider{ width:160px; }
  </style>
</head>

<body>
  <div class="stageWrap">
    <!-- UIはステージの上に重ねる -->
    <div class="toolbar" id="toolbar">
      <div class="left">
        <input id="picker" type="file" accept="image/*" multiple />
        <button class="btn" id="toggle">一時停止</button>
        <label class="hint">速度:
          <input id="speed" type="range" min="20" max="220" value="90" />
        </label>
      </div>
      <div class="hint">5秒後に自動でUI非表示 / タップ or マウス移動で再表示</div>
    </div>

    <div class="stage" id="stage">
      <div class="dropOverlay" id="overlay">
        <div>
          <div style="font-size:16px; font-weight:700; margin-bottom:6px;">ここに写真をドロップ</div>
          <div class="hint">横写真が多くてもOK。フィルム風に自動で流します。</div>
        </div>
      </div>

      <div class="pausedBadge">PAUSED</div>

      <div class="film">
        <div class="sprocket left" id="holesL"></div>
        <div class="sprocket right" id="holesR"></div>

        <div class="window">
          <div class="strip" id="strip"></div>
        </div>

        <div class="grain"></div>
        <div class="vignette"></div>
      </div>

      <!-- ===== Crop Editor Overlay ===== -->
      <div class="editorOverlay" id="editor">
        <div class="editorPanel">
          <div class="left">
            <span class="hint">PAUSED中：ドラッグで位置 / ピンチ or スライダーで拡大</span>
            <label class="hint">ズーム
              <input class="slider" id="zoom" type="range" min="1" max="2.5" step="0.01" value="1">
            </label>
          </div>
          <div class="right" style="display:flex; gap:8px; align-items:center;">
            <button class="btn" id="resetCrop">リセット</button>
            <button class="btn" id="saveCrop">保存</button>
            <button class="btn" id="closeCrop">閉じる</button>
          </div>
        </div>

        <div class="editorStage">
          <div class="editorFrame">
            <img id="editorImg" alt="">
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const stage = document.getElementById('stage');
    const picker = document.getElementById('picker');
    const strip = document.getElementById('strip');
    const toggleBtn = document.getElementById('toggle');
    const speedSlider = document.getElementById('speed');
    const overlay = document.getElementById('overlay');
    const toolbar = document.getElementById('toolbar');

    // ===== UI 自動非表示（5秒）=====
    const UI_HIDE_DELAY_MS = 5000;
    let uiTimer = null;

    function hideUI(){
      toolbar.classList.add('hidden');
      clearTimeout(uiTimer);
      uiTimer = null;
    }
    function resetHideUITimer(){
      clearTimeout(uiTimer);
      uiTimer = setTimeout(hideUI, UI_HIDE_DELAY_MS);
    }
    function showUI(){
      toolbar.classList.remove('hidden');
      resetHideUITimer();
    }
    // 初回：起動して5秒でUIを消す（=“再生開始”）
    resetHideUITimer();

    // ===== プレースホルダ（未選択時）=====
    const placeholderSvgs = Array.from({length: 8}).map((_,i)=>{
      const bg = (i%2===0) ? '#2c3e50' : '#34495e';
      const text = `PHOTO ${i+1}`;
      const svg = encodeURIComponent(`
        <svg xmlns="http://www.w3.org/2000/svg" width="1200" height="700">
          <rect width="100%" height="100%" fill="${bg}"/>
          <text x="50%" y="50%" fill="#ecf0f1" font-size="90" font-family="system-ui"
            text-anchor="middle" dominant-baseline="middle">${text}</text>
        </svg>
      `);
      return \`data:image/svg+xml;charset=utf-8,\${svg}\`;
    });

    let urls = [...placeholderSvgs];
    let paused = false;

    // ===== 穴の数：最下部まで埋める（上下余白も均等）=====
    function buildHoles(){
      const holesL = document.getElementById('holesL');
      const holesR = document.getElementById('holesR');
      holesL.innerHTML = '';
      holesR.innerHTML = '';

      const stageRect = stage.getBoundingClientRect();
      const styles = getComputedStyle(document.documentElement);

      const holeH = parseFloat(styles.getPropertyValue('--hole-h'));
      const gap   = parseFloat(styles.getPropertyValue('--hole-gap'));

      const approxPad = 12; // 初期推定（あとで上書き）
      const usableH = stageRect.height - approxPad * 2;
      const unit = holeH + gap;

      let count = Math.ceil(usableH / unit);
      if (count < 1) count = 1;

      const needed = (count * holeH) + ((count - 1) * gap);
      let pad = (stageRect.height - needed) / 2;
      pad = Math.max(6, pad);

      document.documentElement.style.setProperty('--sprocket-pad', `${pad}px`);

      for(let i=0;i<count;i++){
        const a = document.createElement('div');
        a.className = 'hole';
        const b = document.createElement('div');
        b.className = 'hole';
        holesL.appendChild(a);
        holesR.appendChild(b);
      }
    }

    // ===== Crop data: 画像ごとの表示調整を保持 =====
    // key: 画像URL（ObjectURL含む） / value: {scale, x, y}
    const cropMap = new Map();

    function applyCropsToVisibleFrames(){
      const imgs = strip.querySelectorAll('.frame img');
      imgs.forEach(img=>{
        const key = img.src;
        const saved = cropMap.get(key);
        if(saved){
          img.style.transformOrigin = 'center center';
          img.style.transform = `translate(${saved.x}px, ${saved.y}px) scale(${saved.scale})`;
        }else{
          img.style.transform = '';
        }
      });
    }

    // コマ生成（無限ループのため2回並べる）
    function renderFrames(){
      strip.innerHTML = '';
      const doubled = [...urls, ...urls];

      doubled.forEach((src)=>{
        const frame = document.createElement('div');
        frame.className = 'frame';

        const img = document.createElement('img');
        img.src = src;
        img.loading = 'eager';

        // 保存済みcropがあれば反映
        const saved = cropMap.get(src);
        if(saved){
          img.style.transformOrigin = 'center center';
          img.style.transform = `translate(${saved.x}px, ${saved.y}px) scale(${saved.scale})`;
        }

        frame.appendChild(img);
        strip.appendChild(frame);

        // ★PAUSED中だけクリックで編集を開く
        frame.addEventListener('click', (e)=>{
          e.stopPropagation();
          if(!paused) return;
          openEditorFor(src);
        });
      });
    }

    // ===== アニメーション =====
    let y = 0;
    let lastT = performance.now();

    function tick(t){
      const dt = (t - lastT) / 1000;
      lastT = t;

      if(!paused){
        const speed = Number(speedSlider.value);
        y -= speed * dt;

        const halfHeight = strip.scrollHeight / 2;
        if(Math.abs(y) >= halfHeight){
          y += halfHeight;
        }
        strip.style.transform = `translateY(${y}px)`;
      }

      requestAnimationFrame(tick);
    }

    // ===== 画像追加 =====
    function addFiles(fileList){
      const files = Array.from(fileList).filter(f => f.type.startsWith('image/'));
      if(files.length === 0) return;

      const isPlaceholderOnly = urls.every(u => u.startsWith('data:image/svg+xml'));
      if(isPlaceholderOnly) urls = [];

      const newUrls = files.map(f => URL.createObjectURL(f));
      urls.push(...newUrls);

      renderFrames();
      y = 0;
      showUI();
    }

    picker.addEventListener('change', (e)=> addFiles(e.target.files));

    // ===== Pause/Resume =====
    function togglePause(){
      // エディタが開いてる時はまず閉じる
      if(editor.classList.contains('show')) closeEditor();

      paused = !paused;
      stage.classList.toggle('paused', paused);
      toggleBtn.textContent = paused ? '再開' : '一時停止';
      showUI();
    }
    toggleBtn.addEventListener('click', (e)=>{ e.stopPropagation(); togglePause(); });
    speedSlider.addEventListener('input', ()=> showUI());

    // ステージタップ：UI表示（再生は止めない）
    stage.addEventListener('click', ()=> showUI());

    // PC：マウス動かしたらUI表示
    window.addEventListener('mousemove', ()=> showUI(), {passive:true});
    // スマホ：タッチしたらUI表示
    window.addEventListener('touchstart', ()=> showUI(), {passive:true});

    // DnD
    stage.addEventListener('dragenter', (e)=>{ e.preventDefault(); overlay.classList.add('show'); showUI(); });
    stage.addEventListener('dragover', (e)=>{ e.preventDefault(); });
    stage.addEventListener('dragleave', (e)=>{ e.preventDefault(); overlay.classList.remove('show'); });
    stage.addEventListener('drop', (e)=>{
      e.preventDefault();
      overlay.classList.remove('show');
      if(e.dataTransfer?.files) addFiles(e.dataTransfer.files);
    });

    // ===== Crop Editor =====
    const editor = document.getElementById('editor');
    const editorImg = document.getElementById('editorImg');
    const zoom = document.getElementById('zoom');
    const btnReset = document.getElementById('resetCrop');
    const btnSave = document.getElementById('saveCrop');
    const btnClose = document.getElementById('closeCrop');

    let editingKey = null;
    let current = { scale: 1, x: 0, y: 0 };

    function applyTransformToImg(imgEl, t){
      imgEl.style.transform = `translate(${t.x}px, ${t.y}px) scale(${t.scale})`;
    }

    function openEditorFor(srcKey){
      if(!paused) return;
      editingKey = srcKey;

      const saved = cropMap.get(srcKey);
      current = saved ? {...saved} : { scale: 1, x: 0, y: 0 };

      editorImg.src = srcKey;
      zoom.value = String(current.scale);
      applyTransformToImg(editorImg, current);

      editor.classList.add('show');
      showUI();
    }

    function closeEditor(){
      editor.classList.remove('show');
      editingKey = null;
    }

    zoom.addEventListener('input', ()=>{
      current.scale = Number(zoom.value);
      applyTransformToImg(editorImg, current);
    });

    btnReset.addEventListener('click', ()=>{
      current = { scale: 1, x: 0, y: 0 };
      zoom.value = "1";
      applyTransformToImg(editorImg, current);
    });

    btnSave.addEventListener('click', ()=>{
      if(!editingKey) return;
      cropMap.set(editingKey, {...current});
      applyCropsToVisibleFrames();
      closeEditor();
    });

    btnClose.addEventListener('click', closeEditor);

    // Overlay背景タップで閉じる（パネル内クリックは無視）
    editor.addEventListener('click', (e)=>{
      if(e.target === editor) closeEditor();
    });

    // Drag to pan (editor)
    let dragging = false;
    let last = {x:0, y:0};

    editorImg.addEventListener('pointerdown', (e)=>{
      dragging = true;
      editorImg.setPointerCapture(e.pointerId);
      last = {x:e.clientX, y:e.clientY};
    });

    editorImg.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - last.x;
      const dy = e.clientY - last.y;
      last = {x:e.clientX, y:e.clientY};
      current.x += dx;
      current.y += dy;
      applyTransformToImg(editorImg, current);
    });

    editorImg.addEventListener('pointerup', ()=>{ dragging = false; });
    editorImg.addEventListener('pointercancel', ()=>{ dragging = false; });

    // Pinch zoom (mobile)
    let pinch = {active:false, dist:0, startScale:1};
    function dist2(a,b){
      const dx = a.clientX - b.clientX;
      const dy = a.clientY - b.clientY;
      return Math.hypot(dx,dy);
    }

    editorImg.addEventListener('touchstart', (e)=>{
      if(e.touches.length === 2){
        pinch.active = true;
        pinch.dist = dist2(e.touches[0], e.touches[1]);
        pinch.startScale = current.scale;
      }
    }, {passive:false});

    editorImg.addEventListener('touchmove', (e)=>{
      if(!pinch.active || e.touches.length !== 2) return;
      e.preventDefault();
      const d = dist2(e.touches[0], e.touches[1]);
      const ratio = d / pinch.dist;
      current.scale = Math.min(2.5, Math.max(1, pinch.startScale * ratio));
      zoom.value = String(current.scale);
      applyTransformToImg(editorImg, current);
    }, {passive:false});

    editorImg.addEventListener('touchend', (e)=>{
      if(e.touches.length < 2) pinch.active = false;
    });

    // ===== 初期化 =====
    window.addEventListener('resize', buildHoles);
    buildHoles();
    renderFrames();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
